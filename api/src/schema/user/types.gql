enum Role {
  USER
  ADMIN
}

# """
# Testing descr
# """
type User {
  # Fields
  "Does this work?"
  username: String!
  createdAt: DateTime!

  # Relations
  votes: [VOTED_ON!]!
  proficiencies: [PROFICIENCY!]!

  # Functions
  discover: [Resource!]!
  search (topic: String!): [Resource!]!
}

type AnonymousUser {
  ip: String!
  votes: [VOTED_ON_ANONYMOUS!]!
}

type VOTED_ON @relation(name: "VOTED_ON") {
  from: User!
  to: AmosGame!
  timestamp: DateTime!
}

type VOTED_ON_ANONYMOUS @relation(name: "VOTED_ON_ANONYMOUS") {
  from: AnonymousUser!
  to: Foo!
  # timestamp: DateTime!
}

type Foo {
  bar: String!
}

type PROFICIENCY @relation (name: "PROFICIENCY") {
  from: User!
  to: Topic!
}

input LoginInput {
  usernameOrEmail: String!
  password: String!
}

input AuthFacebookInput {
  fbAccessToken: String!
}

input AuthGithubInput {
  code: String!
}

extend type Query {
  login (input: LoginInput!): Response!
  authFacebook (input: AuthFacebookInput!): Response!
  authGithub (input: AuthGithubInput!): Response!
  # currentUser (name: String): String
  # users: [User!] @hasRole (roles: [ADMIN])
  #   @cypher(
  #     statement: "MATCH (u:User) WITH { username: u.username, id: u.id, email: u.email} as User RETURN User"
  #   )
}

input SignupInput {
  username: String!
  email: String!
  password: String!
  repeatPassword: String!
}

input SignupFacebookInput {
  fbAccessToken: String!
  username: String!
}

input SignupGithubInput {

  username: String!
}

extend type Mutation {
  signup (input: SignupInput!): Response!
  signupFacebook (input: SignupFacebookInput!): Response!
  signupGithub (input: SignupGithubInput!): Response!
  # updatePassword (email: String!, password: String!, _new: String!): String!
  # selfAttest (topic: String!): Boolean!
}
